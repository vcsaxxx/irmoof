# Автономный скрипт для выполнения через irm URL | iex
# Версия 2.0 - Расширенный функционал

function Main-Execution {
    # Часть A: Сбор информации о системе
    $SystemData = @{
        ComputerName = $env:COMPUTERNAME
        UserName = $env:USERNAME
        OSVersion = [System.Environment]::OSVersion.VersionString
        DateTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        IPAddress = (Test-Connection -ComputerName (hostname) -Count 1).IPv4Address.IPAddressToString
    }
    
    # Часть B: Создание отчета
    $ReportPath = "$env:TEMP\System_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
    $SystemData | ConvertTo-Json | Out-File -FilePath $ReportPath -Encoding UTF8
    
    # Часть C: Основные действия скрипта
    # 1. Оптимизация системы
    Optimize-System
    
    # 2. Настройка безопасности
    Configure-Security
    
    # 3. Установка необходимых компонентов
    Install-Components
    
    # 4. Создание резервных копий
    Create-Backups
    
    return $SystemData
}

function Optimize-System {
    # Шаг A: Очистка временных файлов
    Get-ChildItem -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue | 
    Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-7) } | 
    Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
    
    # Шаг B: Оптимизация диска
    Optimize-Volume -DriveLetter C -Verbose -ErrorAction SilentlyContinue
    
    # Шаг C: Настройка энергосбережения
    powercfg -change -standby-timeout-ac 0
    powercfg -change -monitor-timeout-ac 30
}

function Configure-Security {
    # Шаг A: Настройка брандмауэра
    Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled True
    
    # Шаг B: Отключение небезопасных служб
    $UnsafeServices = @("RemoteRegistry", "Telnet", "W3SVC")
    foreach ($service in $UnsafeServices) {
        Stop-Service -Name $service -Force -ErrorAction SilentlyContinue
        Set-Service -Name $service -StartupType Disabled -ErrorAction SilentlyContinue
    }
    
    # Шаг C: Настройка политик паролей
    secedit /export /cfg "$env:TEMP\secpol.cfg"
    (Get-Content "$env:TEMP\secpol.cfg") -replace "MinimumPasswordAge = \d+", "MinimumPasswordAge = 0" | 
    Set-Content "$env:TEMP\secpol.cfg"
    secedit /configure /db "$env:TEMP\secedit.sdb" /cfg "$env:TEMP\secpol.cfg"
}

function Install-Components {
    # Шаг A: Проверка и установка .NET Framework
    if (-not (Get-WindowsFeature -Name "NET-Framework-45-Core").Installed) {
        Enable-WindowsOptionalFeature -Online -FeatureName "NetFx4-AdvSrvs" -All -NoRestart
    }
    
    # Шаг B: Установка необходимых модулей PowerShell
    $Modules = @("PSReadLine", "PackageManagement", "PSScriptAnalyzer")
    foreach ($module in $Modules) {
        if (-not (Get-Module -ListAvailable -Name $module)) {
            Install-Module -Name $module -Force -Confirm:$false -AllowClobber
        }
    }
    
    # Шаг C: Настройка политики выполнения
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
}

function Create-Backups {
    # Шаг A: Создание точки восстановления
    Checkpoint-Computer -Description "AutoBackup_$(Get-Date -Format 'yyyyMMdd_HHmmss')" -RestorePointType "MODIFY_SETTINGS"
    
    # Шаг B: Резервное копирование реестра
    $RegBackupPath = "$env:USERPROFILE\Desktop\RegBackup_$(Get-Date -Format 'yyyyMMdd').reg"
    reg export "HKCU\Software" $RegBackupPath /y
    
    # Шаг C: Резервное копирование важных папок
    $ImportantFolders = @("$env:USERPROFILE\Documents", "$env:USERPROFILE\Desktop")
    $BackupDir = "C:\Backup_$(Get-Date -Format 'yyyyMMdd')"
    New-Item -ItemType Directory -Path $BackupDir -Force
    foreach ($folder in $ImportantFolders) {
        if (Test-Path $folder) {
            Copy-Item -Path $folder -Destination $BackupDir -Recurse -Force
        }
    }
}

# Дополнительные утилиты
function Show-Menu {
    Write-Host "=== СИСТЕМА УПРАВЛЕНИЯ ===" -ForegroundColor Cyan
    Write-Host "1. Показать информацию о системе"
    Write-Host "2. Запустить оптимизацию"
    Write-Host "3. Проверить обновления"
    Write-Host "4. Создать полный отчет"
    Write-Host "5. Выход"
}

function Get-Updates {
    # Проверка обновлений Windows
    $Session = New-Object -ComObject Microsoft.Update.Session
    $Searcher = $Session.CreateUpdateSearcher()
    $SearchResult = $Searcher.Search("IsInstalled=0 and Type='Software'")
    
    $Updates = @()
    foreach ($Update in $SearchResult.Updates) {
        $Updates += @{
            Title = $Update.Title
            KB = $Update.KBArticleIDs -join ", "
            Size = "{0:N2} MB" -f ($Update.MaxDownloadSize / 1MB)
        }
    }
    return $Updates
}

# Главный блок выполнения
try {
    Write-Host "=== СКРИПТ АКТИВИРОВАН ===" -ForegroundColor Green
    Write-Host "Время запуска: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    Write-Host "Пользователь: $env:USERNAME"
    Write-Host "Компьютер: $env:COMPUTERNAME"
    Write-Host ""
    
    # Выполнение основных функций
    $Result = Main-Execution
    
    Write-Host ""
    Write-Host "=== ОТЧЕТ ===" -ForegroundColor Yellow
    Write-Host "1. Оптимизация системы: ВЫПОЛНЕНО"
    Write-Host "2. Настройка безопасности: ВЫПОЛНЕНО"
    Write-Host "3. Установка компонентов: ВЫПОЛНЕНО"
    Write-Host "4. Резервное копирование: ВЫПОЛНЕНО"
    Write-Host ""
    Write-Host "Отчет сохранен: $ReportPath"
    Write-Host "Скрипт успешно выполнен!" -ForegroundColor Green
    
    # Показать меню дополнительных действий
    Show-Menu
    
} catch {
    Write-Host "Ошибка выполнения: $_" -ForegroundColor Red
    Write-Host "Подробности: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

# Финализация
Write-Host ""
Write-Host "Для продолжения нажмите любую клавишу..."
$Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown") | Out-Null